## 垃圾回收机制

`GC ` 即 `Garbage Collection`, 一般的高级语言里面会自带 `GC`，比如 `Java、Python、JavaScript` 等，也有无 `GC` 的语言，比如 `C、C++` 等，这种就需要手动管理内存了。浏览器会（定时）执行垃圾回收，释放内存，避免内存过高导致程序崩溃。

### 变量生命周期

与其叫变量声明周期，其实是**<font color='#EA0000'>占用内存的对象、值的生命周期</font>**。

1. 全部变量：定义在所有函数之外的变量

   一般不会被回收

2. 局部变量：定义在某个函数中的变量

   不用了一般就会被回收

<font color='#8600FF'>局部变量</font>旨在函数执行过程中存在，而在这个过程中会为<font color='#8600FF'>局部变量</font>在栈或者堆上<font color='#EA0000'>分配相应的内存空间</font>，以存储它们的值，然后在函数中使用这些变量，直到函数结束，就会释放这些局部变量所占用的内存空间。

所以，垃圾回收必须知道哪个变量有用，哪个变量没用

### 标记清除算法

在 `Javascript` 内存管理中有个概念叫：**<font color='#EA0000'>可达性</font>**，就是**以某种方式可访问的值**，它们<font style="background-color:#ff0">需要被保证存于内存中</font>，反之，没被保证的则需回收。

浏览器需要定时检查垃圾进行清理，至于如何找到这些需要回收的垃圾，就需要一些算法策略了！其中最常见的一种就是：**<font color='#8600FF'>标记清除算法</font>**。

该算法会在<font color='#8600FF'>运行阶段（标记阶段）</font>给存储在内存中的所有<font color='#EA0000'>活动对象</font>加上标记，此后在<font color='#8600FF'>清除阶段</font>把<font color='#EA0000'>没有标记的（非活动对象）</font>销毁。

例如：*某个函数执行完之后，其中的局部变量就会被清除标记，等待下次被清理*。

清除算法的大致过程：

* 在运行时，给所有变量加上标记为0，假设所有对象都是垃圾
* 然后从各个根对象（Window顶级对象等）开始遍历，把不是垃圾的节点改为 1（<font style="background-color:#ff0">也就是可以遍历到的节点，说明都有被引用</font>）
* 清理所有标记为0的垃圾，回收内存
* 最后，把所有内存标记修改为0，等待下一轮垃圾回收。

清除算法优点就是简单，缺点就是：会造成内存碎片，导致剩余的空闲内存不是一整块： 

![image-20220621180435121](笔记Images/image-20220621180435121.png) 

对于该缺点，需要另一个算法来解决：**<font color='#8600FF'>标记整理（Mark-compact）算法</font>**

该算法会在标记结束后<font color='#EA0000'>不立即清理</font>，而是<font style="background-color:#ff0">先将活着的对象向内存的一端移动</font>，最后清理边界的内存。

![image-20220621180803906](笔记Images/image-20220621180803906.png)



## V8对GC的优化

V8就是基于上述的 **<font color='#8600FF'>标记清除垃圾回收机制 </font>**进行了优化

### 内存结构

在 V8引擎的 **堆结构** 中，主要有 **<font color='#8600FF'>新生代 </font>**和 **<font color='#8600FF'>老生代</font>**

因为上述的垃圾清理算法每次垃圾回收，都要<font color='#EA0000'>检查内存中所有对象</font>，这样，对于<font color='#EA7500'>存活时间过长、或存活时间过短</font>的对象，<font style="background-color:#ff0">保持一种检查频率</font>，其实并**<font color='#EA0000'>不高效</font>**。

因此，就有了 **<font color='#EA0000'>分代式垃圾回收机制</font>**，也就产生了上述的 **<font color='#8600FF'>新生代 </font>**和 **<font color='#8600FF'>老生代</font>**，<font style="background-color:#ff0">两个区域采用不同的垃圾回收策略</font>。

新生代存放<font color='#8600FF'> 存活时间比较短的对象</font> / <font color='#8600FF'>新产生的对象</font>，通常只支持`1~8M`的容量，而老生代的对象为 <font color='#8600FF'>存活时间较长 / 常驻内存的对象</font>（经历过新生代垃圾回收还存活的对象），容量较大。

V8的内存结构图如下：

![image-20220621200812555](笔记Images/image-20220621200812555.png) 

#### 新生代

新生代的对象采用<font color='#8600FF'> `Scavenge 算法`</font>（采用复制式的 `Cheney 算法`） 进行垃圾回收。

`Cheney算法`中将堆内存一分为二，一个是处于使用状态的空间（**<font color='#EA0000'>使用区</font>**），一个是处于闲置状态的空间（<font color='#EA0000'>**空闲区**</font>）

![image-20220621201423656](笔记Images/image-20220621201423656.png) 

<font color='#8600FF'>新加入的对象</font>都会放到<font color='#8600FF'>使用区</font>，当<font color='#8600FF'>使用区</font>快被<font color='#EA0000'>**写满**</font>时，就需要执行一次垃圾清理操作。

当开始进行垃圾回收时

* 新生代垃圾回收器会<font style="background-color:#ff0">对使用区中的活动对象做**标记**</font>
* 标记完成之后将使用区的<font style="background-color:#ff0">活动对象<font color='#EA0000'>复制进空闲区</font></font>并进行排序
* 随后，进入垃圾清理阶段，将非活动对象占用的空间清理掉。
* 最后进行角色互换，把原来的使用区视为空闲区，把原来的空闲区视为使用区

##### 晋升机制

上述过程中，若遇到某些 <font color='#8600FF'>活动对象 </font>

* 经历过 `Scavenge`回收，
* 或 空闲区空间占用超过了 25%，

那么这些对象就会**<font color='#8600FF'>被直接晋升到老生代</font>**空间中。

**<font color='#EA0000'>25%</font>**是因为空闲区将会翻转为使用区，若使用区<font color='#EA7500'>占比过大</font>，用来进行对象内存分配，<font color='#EA0000'>将会影响后续内存分配</font>。

#### 老生代

对于老生代的垃圾回收策略，因为老生代的对象通常比较大，用新生代的回收策略复制来复制去会非常耗时，效率不高，

所以，老生代采用上述的<font color='#8600FF'> **清除标记算法 + 清除整理算法**</font> 进行垃圾回收

### 分代策略的优点：

将新、小、存活时间短的对象作为新生代，采用一小块内存**<font color='#EA0000'>高频率</font>**清理垃圾；

将大、老、存活时间旧的对象作为老生代，采用一大块内存**<font color='#EA0000'>低频率</font>**清理垃圾。

<font style="background-color:#ff0">很大程度提高了垃圾回收机制的效率。</font>

### 其它优化点：

#### 并行回收

因为在回收时，这个过程<font style="background-color:#ff0">内存是静态的</font>（主线程JS代码暂停运行）

所以不用考虑内存中对象的引用关系改变，只需要考虑协同

因此，可以使用**<font color='#8600FF'>多个线程</font>**<font color='#EA0000'>并行</font>进行垃圾回收，新生代就采用了并行策略。

这些线程同时将对象空间中的数据移动到空闲区。

#### 增量标记与惰性清理

上面所说的并行策略，虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种**<font color='#EA0000'>全停顿式</font>**的垃圾回收方式。

对于<font color='#8600FF'>**老生代**</font>来说，存放的都是比较大的对象，即时用并行策略，依然可能<font color='#EA0000'>消耗大量时间</font>，造成<font color='#EA0000'>停顿感</font>。

因此，`V8` 通过 **<font color='#8600FF'>三色标记法</font>** 与 <font color='#8600FF'>**写屏障**</font> 两个方案，实现了增量标记与惰性清理（将一次 `GC` 过程，分成很多小步，每执行完一小步，就让 `JS`代码执行一会儿）

![image-20220621213732640](笔记Images/image-20220621213732640.png) 



##### 三色标记法

该方法将标记清除算法中的 0、1状态，分为更细化的 三种标记状态<font color='#8600FF'>：白、灰、黑</font>。

- 白色指的是未被标记的对象
- 灰色指自身被标记，成员变量（该对象的引用对象）未被标记
- 黑色指自身和成员变量皆完成标记工作

![image-20220621214040761](笔记Images/image-20220621214040761.png) 

过程：

* 最初都是白色对象，意味着回收器没有标记它们
* 从根对象开始，将根对象标记为灰色，开始推入标记工作表中
* 当回收器从标记工作表中弹出对象时，完成该对象内的标记工作时，由灰色转为黑色
* 就这样一直往下走，直到没有灰色节点
* 这样，每次暂停执行，恢复时直接从灰色节点开始继续执行就可以

通过三色标记，可以<font style="background-color:#ff0">很好的配合增量回收进行暂停恢复</font>，从而减少 `全停顿` 的时间

##### 写屏障

由于垃圾回收和JS代码交替执行，有时会出现这样的情况：

假如我们有 `A、B、C` 三个对象依次引用，在第一次增量分段中全部标记为黑色（活动对象），而后暂停开始执行应用程序也就是 JavaScript 脚本，在脚本中我们将对象 `B` 的指向由对象 `C` 改为了对象 `D` ，接着恢复执行下一次增量分段。

![image-20220621223917702](笔记Images/image-20220621223917702.png) 

但是，白色对象 `D` 可以在次轮 `GC` 的清理阶段被回收，然而后面的程序可能还会用 `D`。这样一定会出问题。

所以，`写屏障 (Write-barrier) `机制，就是为了防止这种情况引发问题

即：<font color='#EA0000'>一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色</font>，从而保证正确标记。

这个机制也称为：<font color='#8600FF'>强三色不变性</font>

#### 增量标记与惰性清理的优缺点

虽然使得主线程**<font color='#8600FF'>每次的停顿时间大大减少</font>**，但是<font color='#EA0000'>总的暂停时间其实是略微增加</font>了，其次，由于写屏障机制的成本，增量标记可能还会<font color='#EA0000'>降低应用程序的吞吐量</font>。

#### 并发回收（Concurrent）

该回收机制☞<font style="background-color:#ff0">在主线程执行 `JS` 代码时，辅助线程在后台完成执行垃圾回收的操作</font>，这样主线程就可以不被挂起暂停。

![image-20220621224550042](笔记Images/image-20220621224550042.png) 

由于这种并发模式，堆中的对象引用关系随时都有可能发生变化，辅助线程之前做的一些标记或者正在进行的标记就要做对应的改变，所以它需要**<font color='#EA0000'>额外实现一些读写锁机制</font>**来控制。

#### V8老生代的回收优化

V8中的老生代垃圾回收器，将上述的三种策略进行融合使用，主要是使用了并发标记（也就是标记操作全都由辅助线程完成）

标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）

同时，清理的任务会采用增量的方式分批在各个 `JavaScript` 任务之间执行

### 参考文档：

[掘金文章](https://juejin.cn/post/6981588276356317214)
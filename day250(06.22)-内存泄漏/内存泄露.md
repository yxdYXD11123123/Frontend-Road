## 内存泄漏

### 什么是内存泄漏

`V8`引擎中有垃圾回收机制，可以针对一些程序不再使用的对象，对其清理回收释放内存。

虽然垃圾回收机制做了各种优化，以确保垃圾都被回收，但是<font color='#EA0000'>并不代表</font>，我们<font style="background-color:#ff0">可以完全不用关心这块</font>，我们代码中依然能要<font color='#EA0000'>主动避免一些不利于引擎垃圾回收</font>的操作，因为不是所有无用对象内存都可以被回收。

因此，当不再用到的对象内存，没有及时被回收时，就是：**<font color='#8600FF'>内存泄漏</font>**

### 常见的内存泄漏

下面是内存泄漏的常见案例

#### 不正当的闭包

正当的闭包（不会造成内存泄漏）：

```js
function fn1(){
  let test = {}
  return function(){
    console.log('闭包中 没有引用其它变量')
  }
}
let fn1Child = fn1()
fn1Child()
```

不正当的闭包：

```js
function fn1(){
  let test = {}
  return function(){
      // 闭包中，引用了外部作用域的变量
      return test;
  }
}
let fn1Child = fn1()
fn1Child()
```

`fn1()`是window下面的函数，所以一直被引用，一直是活动对象

`fn1()` 执行一次，就会造成一个新的作用域，在该作用域中，会产生两个新的**<font color='#8600FF'>活动对象</font>**：<font color='#EA0000'>`test`</font> 和 <font color='#EA0000'>` function(){}`</font>

在正当的闭包中，`test` 产生后，没有被任何地方引用

在不正当的闭包中，`test` 产生后，<font color='#EA7500'>被`function(){}` 引用</font>

<font color='#8600FF'>`function(){}` 的引用</font>又被交给 `fn1Child` 变量，<font style="background-color:#ff0">让`window.fn1Child`持有该引用</font>

所以，有了这样<font style="background-color:#ff0">新的引用关系</font>：<font color='#EA0000'>`window <- fn1Child <- test`</font>

因此，`test` 被视为一个**<font color='#8600FF'>活动对象</font>**，以后还是有可能被用到的，所以不可能会进行垃圾回收。

那么，遇到这种问题，如果我们想释放 `test`内存，怎么解决呢？答案就在上面的引用关系中！

```js
fn1Child = null
```

将<font color='#EA0000'> `fn1Child` 的引用置空</font>就可以了，此后`test` 和 ` function(){}`就会被标记为**<font color='#8600FF'>非活动对象</font>**，就会被下次 `GC 垃圾回收` 清理掉释放内存。 

<font style="background-color:#ff0">所以说，使用闭包是可以的，但是要注意使用方式。如果使用了不正当的方式，依然有补救方式（切断引用关系）。</font>

#### 隐式全局变量

如下面函数中的 `test1` 与 `test2` ，其实是被声明到了 `window` 身上，对于全局变量，浏览器时很难判断这些引用是否还需要保留的，所以全局变量通常不会被回收。

```js
function fn(){
  // 没有声明从而制造了隐式全局变量test1
  test1 = new Array(1000).fill('frank')
  
  // 函数内部this指向window，制造了隐式全局变量test2
  this.test2 = new Array(1000).fill('frank')
}
fn()
```

因此，<font style="background-color:#ff0">我们要注意是否会声明为隐式全局变量，使用全局变量后，要注意置空</font>

```js
var test = new Array(10000)

// do something

test = null
```



#### 游离DOM引用

在获取多个Dom使用后，若Dom节点后期被移除，代码中的Dom引用（所有相关联引用）也应该置空，否则 **<font color='#8600FF'>游离的子树</font>** 在内存中无法释放

```html
<div id="root">
  <ul id="ul">
    <li></li>
    <li></li>
    <li id="li3"></li>
    <li></li>
  </ul>
</div>
<script>
  let root = document.querySelector('#root')
  let ul = document.querySelector('#ul')
  let li3 = document.querySelector('#li3')
  
  // 移除Ul
  root.removeChild(ul)
  
  // 这里虽然置空ul变量，但是由于li3变量引用ul的子节点，所以ul元素依然不能被回收
  ul = null
  
  // 已无变量引用，此时才可以回收 ul和li3 游离子树
  li3 = null
</script>
```

#### 遗忘的定时器

定时器： `setTimeout` 和 `setInterval`

```js
setInterval(() => {
	const a = {...}
}, 1000)
```

定时器只要没有执行<font color='#8600FF'> `clearInterval`</font> 或 <font color='#8600FF'>`clearTimeout`</font>，那么定时器<font color='#8600FF'>**回调函数**</font>会一直被视为一个**<font color='#8600FF'>活动对象</font>**，因此，<font color='#EA0000'>回调函数中的引用</font>（依赖的变量a），也<font color='#EA0000'>不会被释放</font>。

`requestAnimationFrame` 也有同样的问题，也要注意使用 `cancelAnimationFrame`

#### 遗忘的事件监听器

这个就比较常见了，在 `Vue` 或 `React` 中，我们可能会在完成挂载时期，进行事件监听，并传入组件内的函数，如下：

```vue
<template>
  <div></div>
</template>

<script>
export default {
  created() {
    window.addEventListener("resize", this.doSomething)
  },
  beforeDestroy(){
    window.removeEventListener("resize", this.doSomething)
  },
  methods: {
    doSomething() {
      // do something
    }
  }
}
</script>
```

如果这些函数内部的引用存有大量的数据，在<font style="background-color:#ff0">组件销毁</font>后，这些**<font color='#8600FF'>事件处理函数</font>**是<font color='#EA0000'>不会被自动回收</font>的，因此可能引起页面占用内存过高，造成意外的内存泄漏。

所以，我们一定要在销毁前，<font color='#EA0000'>移除事件监听器</font>，避免内存泄漏。

#### 遗忘的监听者模式

还有一些**<font color='#8600FF'>监听者模式</font>**工具，会使用组件中的函数，作为事件处理函数

也应该在组件销毁前移除，例如`EventBus`

```vue
<template>
  <div></div>
</template>

<script>
export default {
  created() {
    eventBus.on("test", this.doSomething)
  },
  beforeDestroy(){
    eventBus.off("test", this.doSomething)
  },
  methods: {
    doSomething() {
      // do something
    }
  }
}
</script>
```

#### 遗忘的Map、Set对象

当我们使用 `Map` 和 `Set` 存储对象时，同 `Object` 一致都是**<font color='#EA0000'>强引用</font>**，如果不进行主动清除引用，也会造成内存泄漏。  

此时，我们可以使用 <font color='#8600FF'>`WeakMap` </font>和<font color='#8600FF'> `WeakSet` </font>来代替，这两个是**<font color='#EA0000'>弱引用</font>**，即：<font style="background-color:#ff0">只要引用的存储对象已经没有其它强引用时</font>，该活动对象就会被正常回收。

```js
let obj = {id: 1}
let set = new Set([obj])
let map = new Map([[obj, 'hahaha']])

// 重写obj
obj = null 

console.log(set) // {id:1} 依然在
console.log(map)
```

```js
let obj = {id: 1}
let weakSet = new WeakSet([obj])
let weakMap = new WeakMap([[obj, 'hahaha']])

// 重写obj引用
obj = null

// {id: 1} 将在下一次 GC 中从内存中删除
```

#### 未清理的Console输出

应用发布上线时，记得清除所有 `console` 输出，否则也会造成内存泄漏。 



## 如何排查内存泄漏

通过`Chrome Devtool`中 `PerFormance 面板` 检查是否有泄漏；

通过 `Memony 面板` 定位泄漏源。 



### 内存三大问题

内存泄漏：。。。

内存膨胀：短时间内，内存占用极速上升到达一个峰值，需要使用技术手段减少对内存的占用。

频繁`GC`：频繁使用**<font color='#8600FF'>大量的临时变量</font>**，导致**新生代**空间快速装满，上文也说了，新生代装满就会<font color='#EA0000'>主动触发 `GC 垃圾回收` </font>。



### 参考文献：

[硬核`JS`](https://juejin.cn/post/6984188410659340324#heading-0)
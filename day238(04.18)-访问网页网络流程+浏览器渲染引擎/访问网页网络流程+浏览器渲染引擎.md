## 网络

当用户访问页面时，浏览器需要获取用户请求内容，这个过程主要涉及浏览器网络模块。

- 用户在地址栏输入域名，比如，`baidu.com`

- `DNS`（又称域名解析系统，默认端口号53）协议，<font color='#EA7500'>**通过域名查找`IP`地址**</font>

  浏览器`DNS`解析大多时候比较快，且会缓存常用域名的解析值，但是如果网站涉及多域名，在对每一个域名访问时都需要先解析出`IP`地址，而我们希望在跳转或者请求其他域名资源时尽量快，则可以开启域名预解析，浏览器会在空闲时提前解析声明需要预解析的域名。如下

​		即，在网页头部（head之间）增加<font color='#8600FF'>**rel属性为 `”dns-prefetch”` 的link标签**</font>，并在 `href` 中指定想要预解析的域名。

- <font color='#EA7500'>**向该`IP`地址发起请求**</font>。请求过程如下

  * 客户端：

    HTTP协议<font color='#EA7500'>**生成**</font>针对目标Web服务器的<font color='#EA7500'>**HTTP请求报文**</font>；

    为了方便通信，<font color='#EA0000'>**HTTP请求报文**将HTTP报文分割成**报文段**</font>，把每个报文段可靠地传给对方；

    <font color='#EA0000'>**`ARP`协议**</font>根据IP地址<font color='#EA0000'>**解析**</font>出对应的**<font color='#EA0000'>MAC地址</font>**

    <font color='#EA0000'>**`IP`协议**</font>根据**<font color='#EA0000'>MAC地址</font>**传送报文。

    这期间可能会经过多个路由器，<font color='#EA7500'>IP协议自动中转</font>，直到**找到**目的MAC；

  * 服务器端：

    **TCP协议**从客户端**<font color='#EA7500'>接收到报文段</font>**，按序号以原来的顺序**<font color='#EA0000'>重组请求报文</font>**；

    **HTTP协议**对Web服务器**请求**的内容进行**处理**。此时，服务器知道了客户端想要浏览 `baidu.com` 这个页面了；

- 浏览器**<font color='#EA7500'>获得并解析</font>**服务器的返回内容（**HTTP Response**）

- 浏览器**<font color='#EA7500'>加载</font>**HTML文件以及文件内包含的外部引用文件以及图片，多媒体等<font color='#EA7500'>**资源**</font>。



## 浏览器渲染引擎

### 工作流程

通过浏览器的网络模块加载到HTML文件，渲染流程：

* 从 Head 标签开始逐行解析HTML代码，遇到 link 标签又会向服务器请求**加载CSS文件**，这个过程是**异步加载**

  如果有**多个CSS文件**，会**同时**加载

* <font color='#e44'>如果遇到 script 标签或者 `js` 文件，会立即执行，并且这个过程是同步的。</font>

  不同于`CSS`文件，`js` 是<font color='#EA0000'>**同步加载**</font>。即执行 `js` 文件时，浏览器不会做其他事情，只有 `js` 代码执行结束后，才会继续开始渲染页面。为了防止出现“空白页”现象，应该<font color='#EA7500'>把 `js` 放到页面底部，也就是 `</body>` 标签前</font>

* 然后到 body 标签开始渲染页面，按照从上到下的顺序依次渲染 `dom` 节点。如果遇到 `img` 标签，会**<font color='#EA0000'>异步</font>**向服务器发送请求<font color='#EA7500'>加载图片文件</font>，浏览器会继续渲染页面

* 如果<font color='#EA7500'>遇到了`dom`节点的变化，元素尺寸变化</font>，浏览器不得不回头重新渲染这部分代码（<font color='#EA0000'>**回流**</font>）



### 什么影响了页面渲染的速率

* **回流、重排（`reflow`）**

  当浏览器发现页面某个部分发生了变化影响了布局，需要倒回去重新渲染，该过程称为回流

* **重绘（`repaint`）**

  如果只是改变了某个元素的边框颜色、字体颜色、背景色等不影响它周围或内部布局的属性，将只会影响浏览器的重绘



### 如何提升页面渲染速率

* **利用`CSS`**

  用CSS动画替代`js`模拟动画的好处是：<font color='#EA7500'>不占用`js`主线程</font>；可以利用**<font color='#EA7500'>硬件加速</font>**；浏览器可对动画做优化。但CSS动画有时会出现卡顿现象

  **使用 `CSS3` 动画造成页面的不流畅和卡顿问题，其<font color='#EA0000'>潜在原因</font>往往还是页面的<font color='#8600FF'>回流和重绘</font>，<font color='#EA7500'>减少页面动画元素对其他元素的影响</font>是提高性能的根本方向。**

  * 设置动画元素 **<font color='#EA0000'>position 样式为absolute或 fixed</font>**，可避免动画的进行对页面其它元素造成影响，导致其重绘和重排的发生；

  * **<font color='#EA0000'>避免</font>**使用<font color='#EA7500'>**margin，top，left，width，height**</font>等属性执行动画，用 **<font color='#8600FF'>transform</font>** 进行替代；

    因为transform属性**不会出发浏览器的 repaint**，而 top 和 left 会一直触发 repaint。为什么 transform 没有触发 repaint 呢？因为，<font color='#EA0000'>transform 动画由 GPU 控制，支持硬件加速</font>，并不需要软件方面的渲染。

* **注意`JS`**

  * 解决同步加载问题

    * 将js文件放在页面底部，即 `</body>` 标签之前。因为html文件默认是按照顺序从上到下依次加载的，这样就可以**<font color='#EA0000'>先渲染dom节点，再加载js</font>**

    * 使用 H5 的**<font color='#EA0000'>async属性</font>**，用法和特点如下

      ```html
      　　<script src = "test.js"  anysc></script>
      　　//加载脚本时不阻塞页面渲染
      　　//使用这个属性的脚本中不能调用document.write方法
      　　//可以只写属性名，不写属性值。写法如上
      　　//H5新增属性
      　　//脚本在下载后立即执行，同时会在window的load事件之前执行，所以有可能出现脚本执行顺序被打乱的情况
      ```

    * 使用HTML的**<font color='#EA0000'>defer属性</font>**，用法和特点如下（前三点和anysc相同）

      ```html
      　<script src = "test.js" defer></script>
      　　//加载脚本时不阻塞页面渲染
      　　//使用这个属性的脚本中不能调用document.write方法
      　　//可以只写属性名，不写属性值。写法如上
      　　//H4属性
      　　//脚本在页面解析完之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行
      ```

      

  * **避免频繁操作DOM元素**

    * <font color='#8600FF'>`createDocumentFragment()` 方法</font>

      createDocumentFragment()方法，是用来<font color='#EA0000'>创建一个虚拟的节点对象</font>，或者说，是用来创建文档碎片节点，它可以包含各种类型的节点，在创建之初是空的。它有一个很实用的特点，当请求把一个createDocumentFragment 节点插入文档树时，插入的不是createDocumentFragment 自身，而是它所有的子孙节点。

      当需要**添加多个`dom`元素**时，如果先将这些元素添加到createDocumentFragment 中，再<font style="background-color:#ff0">统一</font>将createDocumentFragment 添加到页面。因为文档片段存在于**<font color='#EA0000'>内存</font>**中，并不在DOM中，所以将子元素插入文档片段中<font color='#EA7500'>不会引起回流</font>（对元素位置和几何上的计算），因此，使用createDocumentFragment可以起到<font color='#EA0000'>性能优化</font>的作用。

      ```js
      　　let ul = documen.getElementById("ul");
      　　let fragment = document.createDocumentFragment();
      　　for (let i = 0;i < 20;i++){
      　　　　let li = document.createElement("li");
      　　　　li.innerHtml =" index: " + i;
      　　　　fragment.appendChild(li);
      　　}
      　　ul.appendChild(fragment);
      ```

      

    * 设置DOM元素为<font color='#8600FF'><font style="background-color:#ff0">`display`属性为`none`</font></font>再进行操作

      ```js
      　　let myElement = document.getElementById('myElement');
      　　myElement.style.display = 'none';
      　　
      　　…… //一些基于myElement的大量DOM操作
      
      　　myElement.style.display = 'block';
      ```

      

    * **<font color='#EA7500'>复制DOM元素到内存中</font>**再对其进行操作（**vue、react 的虚拟节点** 就是这个道理）

      ```js
      　　let old = document.getElementById('myElement');
      　　let clone = old.cloneNode(true);
      
      　　…… //一些基于clone的大量操作
      
      
      　　old.parentNode.replaceChild(clone,old);
      ```

      

    * 用局部变量**<font color='#EA0000'>缓存样式信息</font>**，从而<font color='#EA7500'>避免频繁获取DOM数据</font>（避免重新计算布局）

      比如访问一个元素的offsetWidth属性时，浏览器需要**<font color='#EA7500'>重新计算</font>**（重新布局），然后才能返回最新的值，如果这个动作发生在一个很大的循环中，那么浏览器就不得不进行多次重新布局，这可能会产生严重的性能问题。

      ```js
      	  //一般用法
      　　for (let i = 0;i < paragraphs.length;i++) {
      　　　　paragraphs.style.width = box.offsetWidth + 'px';
      　　}
      
      　　//优化性能的用法
      　　let width = box.offsetWidth;
      　　for (let i = 0;i < paragraphs.length;i++){
      　　　　paragraphs[i].style.width = width + 'px';
      　　}
      ```

      

    * <font color='#EA7500'>合并多次DOM操作</font>

      ```js
      　　//一般用法
      　　var left = 10;top = 10;
      　　el.style.top = top;
      　　el.style.left = left;
      　　
      　　//优化性能写法
      　　el.style.cssText += ";left: " + left + "px; top: " + top + "px;";
      ```

      

* 其他

  * **资源压缩与合并**

    HTML代码压缩：压缩在文本中有意义，而在HTML中不需要的字符。比如，空格、制表符、换行符，还有一些其他意义的字符，如HTML注释也可以被压缩。

    CSS代码压缩：删除无效的代码和<font color='#EA7500'>css语义合并</font>。

    `JS`的压缩和紊乱：使用在线网站压缩、使用 `html-minifier` 工具、使用`uglifyjs2` 进行压缩。

    文件合并：将多个 `js/css` 小文件合并为一个文件，减少网络请求次数。

    **注：css压缩与js的压缩和紊乱比html压缩收益要大的多，同时css代码和js代码比html代码多的多。所以，<font color='#EA7500'>css与js代码压缩</font>非常有必要！**　

  * **浏览器缓存**

    缓存作用：对于web应用来说，缓存是<font color='#EA0000'>提升页面性能</font>同时<font color='#EA0000'>减少服务器压力</font>的利器。

    * **强缓存：**不会向服务器发送请求，<font style="background-color:#ff0">直接从缓存中读取资源</font>，在Chrome控制台的network选项中可以看到该请求的状态码是 200，但是 size 的标识为 `from dist cache` 或者 `from memory cache`

    * **`response header`：**response header里的过期时间，浏览器再次加载该资源时，如果**<font color='#EA0000'>在有效时间内</font>**，则<font color='#EA0000'>使用强缓存</font>。

    * **`Last-Modified` 和 ` If-Modified-Since`：**二者都是<font color='#8600FF'>记录页面最后修改时间</font>的 HTTP 头信息

      Last-Modified 是由服务器往客户端发送的HTTP，

      If-Modified-Since 是客户端往服务器端发送的头。

      再次请求本地缓存的 cache 页面时，客户端<font style="background-color:#ff0">会通过 `If-Modified-Since` 头先将服务器端发过来的 `Last-Modified` 最后修改时间戳发送回去</font>，这是为了让服务器端进行验证，通过这个**时间戳判断**客户端的页面<font color='#EA7500'>是否是最新的</font>。如果不是最新的，则返回新的内容，如果是最新的，则<font color='#EA7500'>返回 304 </font>告诉客户端其本地 cache 的页面时最新的，于是客户端就可以<font color='#EA0000'>直接从本地加载页面</font>了，这样在**网络上传输的数据**就会**大大减少**，同时也<font color='#EA0000'>减轻了服务器端的负担</font>。

      而在一些ajax应用中，要求回获取的数据永远是最新的，而不是读取缓存中的数据，做这样的设置是很有必要的。

  * **CDN预解析**
  
    CDN服务提供商会有全国各个省份部署节点, 将网站静态资源部署到CDN后, 用户在访问页面时, CDN静态资源会从**<font color='#EA0000'>就近的CDN节点</font>**上加载资源. 
  
    当请求至达CDN节点后, 节点会判断资源是<font color='#EA7500'>**缓存是否有效**</font>, 若有效, 直接返回给用户, 若无效, 会从<font style="background-color:#ff0">CDN服务器加载最新的资源</font>返回给用户<font style="background-color:#ff0">同时将资源保存一份到该CDN节点</font>上, 以便后续的访问用户使用。
  
    因此，只要在该地区有一个用户先加载了资源, 在CDN中<font color='#8600FF'>建立了缓存</font>, 该地区的其他用户都能受益。
  
  * **`DNS` 预解析**
  
    DNS 作为互联网的基础协议，其解析的速度似乎容易被网站优化人员忽视。现在大多数新浏览器已经针对DNS解析进行了优化，典型的一次DNS解析耗费20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。<font color='#8600FF'>**`DNS Prefetching`**</font>是具有此属性的域名<font color='#EA7500'>不需要用户点击</font>链接就在后台<font color='#EA0000'>解析</font>。
    
    因为域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验。

